#pragma once

#ifndef __GRAMMAR_H_
#define __GRAMMAR_H_ 1

#include <string>
#include <utils.h>

typedef std::pair<char,std::string> rule; /* typedef for rule, i.e (S,aSb) */


/* structure which describes a context-free grammar, following its definition 
	G = (V,E,R,S) */
struct ContextFreeGrammar {

	std::string V;
	std::string E;
	std::vector<rule> R;
	char S;

};

/* Verifies if E is included in V */

bool CheckSigmaInclusion(ContextFreeGrammar G) {
	for(int i = 0; i < G.E.length(); i++) {
		if (G.V.find(G.E[i]) == std::string::npos) {
			return false;
		}
	}
	return true;
}

/* verifies if V\E contains only nonterminals */

bool CheckSigmaDifference(ContextFreeGrammar G) {
	for(int i = 0; i < G.V.length(); i++) { 
		if (G.V[i] < 65 || G.V[i] > 90) { /* toti terminalii din V */
			if (G.E.find(G.V[i]) == std::string::npos) { /* sunt si in E */
				return false;
			}
		}
	}
	return true;
}

/* Verifies is S is included in V\E */

bool CheckStartSymbolInclusion(ContextFreeGrammar G) {
	if (G.V.find(G.S) == std::string::npos) {
		return false;
	}
	return true;
}

/* Verifies if the left side of a rule is included in V\E */

bool CheckLeftRuleInclusion(ContextFreeGrammar G) {
	for(int i = 0; i < G.R.size(); i++) {
		if (G.V.find(G.R[i].first) == std::string::npos) {
			return false;
		}
	}
	return true;
}

/* Verifies if the right side of a rule contains symbols from V */

bool CheckRightRuleInclusion(ContextFreeGrammar G) {
	for(int i = 0; i < G.R.size(); i++) {
		for(int j = 0; j < G.R[i].second.length(); j++) {
			if ((G.R[i].second)[j] == 'e') 
				continue;
			if (G.V.find((G.R[i].second)[j]) == std::string::npos) {
				return false;
			}
		}
	}
	return true;
}


/* Verifies if a CFG is semantically valid  */

bool isValid(ContextFreeGrammar G) {
	return (CheckSigmaInclusion(G) &&
			CheckSigmaDifference(G)	&&
			CheckStartSymbolInclusion(G) &&
			CheckLeftRuleInclusion(G) &&
			CheckRightRuleInclusion(G));
}


/* Verifies if the language generated by G contains e */
bool hasE(ContextFreeGrammar G) {

	std::string marked_nonterminals;
	int marked_count = 0;

	do {
		marked_count = 0;

		for (int i = 0; i < G.R.size(); i++) {

			char left_side = G.R[i].first;
			std::string right_side = G.R[i].second;
			bool mark_left_side = true;			

			if (right_side == "e") { /* If right side is e, then we can obtain e from the left side, so we mark it */
				if(AppendNoDuplicates(marked_nonterminals,left_side)) { 
					marked_count++;
				}
			}
			else { /*  if right side is not e */
				if (IsNonterminal(right_side)) { /* it must  contain only nonterminals */
					for(int j = 0; j < right_side.length(); j++) {
						if (marked_nonterminals.find(right_side[j]) == std::string::npos) { /* If one of the nonterminals on the right is not marked, skip the rule */
							mark_left_side = false;
							break;	
						}
					}
					if (mark_left_side) { /* If all right-side terminals are marked, we can mark the left side as well */
						if(AppendNoDuplicates(marked_nonterminals,left_side))
						{
							marked_count++;
						}
					}
				}
				else {
					continue; /* if the rule contains terminals on the right side, skip it */
				}
			}	
		}
	} while(marked_count > 0); /* we examine rules as long as we mark at least a nonterminal */

	if (marked_nonterminals.find(G.S) != std::string::npos) {
		return true;
	}
	return false;
}

std::string GetUselessNonterminals(ContextFreeGrammar G) {

	std::string useful_nonterminals;
	std::string useless_nonterminals;
	int marked_count = 0;

	do {
		marked_count = 0;

		for(int i = 0; i < G.R.size(); i++) {

			bool mark_left_side = true;
			char left_side = G.R[i].first;
			std::string right_side = G.R[i].second;

			if (IsTerminal(right_side)) { /* If right side contains only terminals */
				if (AppendNoDuplicates(useful_nonterminals,left_side)) /* then we can obtain a word from the leftside nonterminal */
				{
					marked_count++;
				}
			}
			else {
				for(int j = 0; j < right_side.length(); j++) {
					if (IsNonterminal(right_side[j])) /* If right side contains only nonterminals */
					{
						if (useful_nonterminals.find(right_side[j]) == std::string::npos) { /* if all terminals on the left are useful */
							mark_left_side = false; 
							break;
						}
					}
				}
				if (mark_left_side) { /* we mark the one on the left */
					if (AppendNoDuplicates(useful_nonterminals,left_side)) {
						marked_count++;
					}
				}
			}
		}
	} while (marked_count > 0); /* we examine rules as long as we mark at least a nonterminal */

	for (int i = 0; i < G.V.size(); i++) {
		if (IsNonterminal(G.V[i])) { 
			if (useful_nonterminals.find(G.V[i]) == std::string::npos) { /* If a nonterminal is not marked as useful */
				AppendNoDuplicates(useless_nonterminals,G.V[i]); /* we mark it as useless */
			}
		}
	}

	return useless_nonterminals;
}

bool IsVoid(ContextFreeGrammar G) {
	if (GetUselessNonterminals(G).find(G.S) != std::string::npos) { /* A generated language is void if the start-symbol is useless */
		return true;
	}
	return false;
}


#endif